<script>
       <script>
    // --- CONFIGURATION ---
    const WORDS = ["algorithm", "neural", "network", "cybernetics", "protocol", "interface", "velocity", "phosphor", "kinetic", "resonance", "system", "mainframe", "encrypted", "binary", "flux", "quantum", "synthesis", "void", "echo", "compile", "debug", "runtime", "stack", "overflow", "memory", "cache"];
    const TEXT_LENGTH = 30;

    // --- AUDIO ENGINE ---
    const SoundEngine = {
        ctx: null,
        combo: 0,
        scale: [261.63, 293.66, 329.63, 392.00, 440.00, 523.25, 587.33, 659.25, 783.99, 880.00],
        
        async init() {
            if (!this.ctx) {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (this.ctx.state === 'suspended') {
                await this.ctx.resume();
            }
        },

        playClick() {
            if (!this.ctx || this.ctx.state !== 'running') return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            const noteIndex = this.combo % this.scale.length;
            osc.frequency.setValueAtTime(this.scale[noteIndex], this.ctx.currentTime);
            osc.type = 'sine';
            gain.gain.setValueAtTime(0, this.ctx.currentTime);
            gain.gain.linearRampToValueAtTime(0.2, this.ctx.currentTime + 0.01);
            gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.1);
            osc.connect(gain);
            gain.connect(this.ctx.destination);
            osc.start();
            osc.stop(this.ctx.currentTime + 0.15);
            this.combo++;
        },

        playError() {
            if (!this.ctx || this.ctx.state !== 'running') return;
            this.combo = 0;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.frequency.value = 100;
            osc.type = 'sawtooth';
            gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.2);
            osc.connect(gain);
            gain.connect(this.ctx.destination);
            osc.start();
            osc.stop(this.ctx.currentTime + 0.2);
        }
    };

    // --- STATE ---
    let state = { started: false, startTime: null, text: "", charIndex: 0, mistakes: 0, correctChars: 0 };

    // --- DOM & CANVAS ---
    const displayText = document.getElementById('display-text');
    const startScreen = document.getElementById('start-screen');
    const glitchOverlay = document.getElementById('glitch');
    const wpmDisplay = document.getElementById('wpm-display');
    const accDisplay = document.getElementById('accuracy-display');
    const canvas = document.getElementById('particleCanvas');
    const ctx = canvas.getContext('2d');
    let width, height, particles = [];

    function resize() {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    // --- PARTICLES ---
    class Particle {
        constructor(x, y, color) {
            this.x = x; this.y = y;
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * 5 + 2;
            this.vx = Math.cos(angle) * speed;
            this.vy = Math.sin(angle) * speed;
            this.life = 1.0;
            this.decay = Math.random() * 0.03 + 0.01;
            this.color = color;
            this.size = Math.random() * 3 + 1;
        }
        update() { this.x += this.vx; this.y += this.vy; this.vy += 0.1; this.vx *= 0.95; this.life -= this.decay; }
        draw(ctx) {
            ctx.save(); ctx.globalAlpha = this.life; ctx.fillStyle = this.color;
            ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill();
            ctx.shadowBlur = 15; ctx.shadowColor = this.color; ctx.restore();
        }
    }

    function spawnParticles(x, y, count = 10, color = '#00f3ff') {
        for (let i = 0; i < count; i++) particles.push(new Particle(x, y, color));
    }

    function animate() {
        ctx.clearRect(0, 0, width, height);
        particles.forEach((p, i) => {
            p.update(); p.draw(ctx);
            if (p.life <= 0) particles.splice(i, 1);
        });
        requestAnimationFrame(animate);
    }
    animate();

    // --- LOGIC ---
    function generateText() {
        let str = "";
        for (let i = 0; i < TEXT_LENGTH; i++) str += WORDS[Math.floor(Math.random() * WORDS.length)] + " ";
        return str.trim();
    }

    function renderText() {
        displayText.innerHTML = '';
        state.text.split('').forEach((char, index) => {
            const span = document.createElement('span');
            span.innerText = char;
            span.className = 'char' + (index === state.charIndex ? ' current' : '');
            displayText.appendChild(span);
        });
    }

    async function initGame() {
        await SoundEngine.init();
        state.text = generateText();
        state.charIndex = 0; state.mistakes = 0; state.correctChars = 0;
        state.started = true; state.startTime = Date.now();
        startScreen.classList.add('hidden');
        renderText();
    }

    window.addEventListener('keydown', (e) => {
        if (!state.started) { initGame(); return; }
        if (e.key.length > 1 && e.key !== 'Backspace') return;

        const charSpans = document.querySelectorAll('.char');
        const currentChar = state.text[state.charIndex];
        const rect = charSpans[state.charIndex].getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;

        if (e.key === currentChar) {
            charSpans[state.charIndex].classList.add('correct');
            spawnParticles(centerX, centerY, 8, '#00f3ff');
            SoundEngine.playClick();
            state.charIndex++; state.correctChars++;
            if (state.charIndex < state.text.length) {
                charSpans[state.charIndex].classList.add('current');
            } else { initGame(); }
        } else {
            state.mistakes++;
            charSpans[state.charIndex].classList.add('wrong');
            glitchOverlay.style.opacity = 1;
            setTimeout(() => glitchOverlay.style.opacity = 0, 100);
            spawnParticles(centerX, centerY, 5, '#ff0055');
            SoundEngine.playError();
        }
        
        const timeElapsed = (Date.now() - state.startTime) / 60000;
        wpmDisplay.innerText = `WPM: ${Math.round((state.correctChars / 5) / timeElapsed) || 0}`;
        accDisplay.innerText = `ACC: ${Math.round(((state.charIndex - state.mistakes) / state.charIndex) * 100) || 100}%`;
    });
</script>
    </script>
